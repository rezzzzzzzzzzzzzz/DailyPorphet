This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    deploy.yml
    simple-deploy.yml
.gitignore
auth-server.js
auth.js
channels.html
channels.js
config.example.js
index.html
login.html
main.js
README.md
style.css
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/deploy.yml">
name: Build and Deploy to GitHub Pages

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Build site with secrets
        env:
          VITE_AUTH_PASSWORD: ${{ secrets.AUTH_PASSWORD }}
        run: |
          # Create config file with secret password
          echo "window.REZZITER_CONFIG = { authPassword: '${{ secrets.AUTH_PASSWORD }}', sessionDuration: 24 * 60 * 60 * 1000 };" > config.local.js
          
          # Copy all files to dist directory
          mkdir -p dist
          cp *.html *.js *.css dist/ 2>/dev/null || true
          
          # Verify config was created
          echo "Config file created:"
          cat dist/config.local.js

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './dist'

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
</file>

<file path=".github/workflows/simple-deploy.yml">
name: Deploy to GitHub Pages with Secrets

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create config with secret
        env:
          AUTH_PASSWORD: ${{ secrets.AUTH_PASSWORD }}
        run: |
          echo "Creating config.local.js with secret password..."
          echo "window.REZZITER_CONFIG = { 
            authPassword: '$AUTH_PASSWORD', 
            sessionDuration: 24 * 60 * 60 * 1000 
          };" > config.local.js
          
          echo "Config created successfully!"

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: '.'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</file>

<file path=".gitignore">
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Local configuration (contains sensitive data)
config.local.js

# Build output
dist/
build/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
</file>

<file path="auth-server.js">
// Alternative: Server-based authentication (more secure)
// This approach validates passwords server-side instead of client-side

const AUTH_API_URL = '/api/auth'; // Your authentication endpoint
const SESSION_KEY = 'rezziter_authenticated';
const SESSION_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

/**
 * Check if user is currently authenticated
 */
function isAuthenticated() {
    const authData = localStorage.getItem(SESSION_KEY);
    if (!authData) return false;
    
    try {
        const { timestamp, token } = JSON.parse(authData);
        const now = Date.now();
        
        // Check if session is still valid (24 hours)
        if (now - timestamp > SESSION_DURATION) {
            localStorage.removeItem(SESSION_KEY);
            return false;
        }
        
        return token ? true : false;
    } catch (e) {
        localStorage.removeItem(SESSION_KEY);
        return false;
    }
}

/**
 * Authenticate user with password via server API
 */
async function authenticate(password) {
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ password })
        });
        
        if (response.ok) {
            const { token } = await response.json();
            const authData = {
                timestamp: Date.now(),
                token: token,
                authenticated: true
            };
            localStorage.setItem(SESSION_KEY, JSON.stringify(authData));
            return true;
        }
        return false;
    } catch (error) {
        console.error('Authentication error:', error);
        return false;
    }
}

/**
 * Logout user
 */
function logout() {
    localStorage.removeItem(SESSION_KEY);
    window.location.href = 'login.html';
}

/**
 * Require authentication - redirect to login if not authenticated
 */
function requireAuth() {
    if (!isAuthenticated()) {
        window.location.href = 'login.html';
    }
}
</file>

<file path="config.example.js">
// Rezziter Frontend Configuration
// Copy this file to config.local.js and update with your values
// config.local.js will be ignored by git

window.REZZITER_CONFIG = {
    authPassword: 'your_password_here',
    sessionDuration: 24 * 60 * 60 * 1000, // 24 hours
    // Add other configuration as needed
};
</file>

<file path="README.md">
# Rezziter - Telegram Message Viewer
</file>

<file path="login.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rezziter - Login</title>
    <link rel="stylesheet" href="style.css">
</head>
<body class="login-body">
    <div class="login-container">
        <div class="login-card">
            <h1 class="login-title">üóûÔ∏è Rezziter</h1>
            <p class="login-subtitle">Enter password to access</p>
            
            <form id="login-form" class="login-form">
                <div class="input-group">
                    <input type="password" id="password" placeholder="Password" required>
                </div>
                <button type="submit" class="login-btn">Access</button>
            </form>
            
            <div id="error-message" class="error-message" style="display: none;"></div>
        </div>
    </div>

    <!-- Load configuration first (GitHub Pages) -->
    <script src="config.local.js"></script>
    <script src="auth.js"></script>
</body>
</html>
</file>

<file path="main.js">
// Rezziter - Frontend JavaScript

// Initialize Supabase client
// NOTE: These are public keys and are safe to expose in frontend code
// Replace these placeholder values with your actual Supabase project credentials
const SUPABASE_URL = 'https://ifdmncyrdvfxkeyzwcgr.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlmZG1uY3lyZHZmeGtleXp3Y2dyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQyMDM5NjMsImV4cCI6MjA2OTc3OTk2M30.B6h3TVKkRYW637P-NfZio_0vCQWEtN70-Z5UA_H26uE';

const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Pagination state
let currentPage = 1;
let pageSize = 20;
let totalMessages = 0;
let currentChannelFilter = 'all';
let currentTagFilter = 'all';

/**
 * Render messages to the page
 * @param {Array} messages - Array of message objects from Supabase
 */
function renderMessages(messages) {
    const messageFeed = document.getElementById('message-feed');
    
    // Clear existing content
    messageFeed.innerHTML = '';
    
    // If no messages, show "Nothing to Show"
    if (!messages || messages.length === 0) {
        const emptyMessage = document.createElement('p');
        emptyMessage.textContent = 'Nothing to Show';
        emptyMessage.className = 'empty-state';
        messageFeed.appendChild(emptyMessage);
        return;
    }
    
    // Create messages
    messages.forEach(message => {
        // Create message container
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message-item';
        
        // Format timestamp (convert ISO string to readable format)
        const timestamp = new Date(message.sent_at).toLocaleString();
        
        // Create header with timestamp and channel name
        const header = document.createElement('p');
        header.innerHTML = `<strong>[${timestamp}] - ${message.channel_name}:</strong>`;
        header.className = 'message-header';
        
        // Create message text
        const messageText = document.createElement('p');
        messageText.textContent = message.message_text;
        messageText.className = 'message-text';
        
        // Append header and text to message container
        messageDiv.appendChild(header);
        messageDiv.appendChild(messageText);
        
        // Handle media if present
        if (message.media_url) {
            const mediaContainer = document.createElement('div');
            mediaContainer.className = 'message-media';
            
            // Check if media is an image
            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
            const isImage = imageExtensions.some(ext => 
                message.media_url.toLowerCase().endsWith(ext)
            );
            
            if (isImage) {
                // Create image element
                const img = document.createElement('img');
                img.src = message.media_url;
                img.alt = 'Message media';
                img.className = 'message-image';
                img.style.maxWidth = '100%';
                img.style.height = 'auto';
                img.style.borderRadius = '0.5rem';
                img.style.marginTop = '0.5rem';
                
                // Add error handling for broken images
                img.onerror = function() {
                    this.style.display = 'none';
                    const errorText = document.createElement('p');
                    errorText.textContent = 'Image could not be loaded';
                    errorText.className = 'media-error';
                    mediaContainer.appendChild(errorText);
                };
                
                mediaContainer.appendChild(img);
            } else {
                // Create download link for other media types
                const mediaLink = document.createElement('a');
                mediaLink.href = message.media_url;
                mediaLink.textContent = 'Download Media';
                mediaLink.className = 'media-link';
                mediaLink.target = '_blank';
                mediaLink.rel = 'noopener noreferrer';
                mediaLink.style.color = '#60a5fa';
                mediaLink.style.textDecoration = 'underline';
                mediaLink.style.display = 'inline-block';
                mediaLink.style.marginTop = '0.5rem';
                
                mediaContainer.appendChild(mediaLink);
            }
            
            messageDiv.appendChild(mediaContainer);
        }
        
        // Add message to feed
        messageFeed.appendChild(messageDiv);
    });
    
    console.log(`‚úÖ Rendered ${messages.length} messages to the page`);
}

/**
 * Show loading indicator
 */
function showLoading() {
    const messageFeed = document.getElementById('message-feed');
    messageFeed.innerHTML = '<p class="loading">Loading...</p>';
}

/**
 * Populate the channel filter dropdown with unique channel names
 */
async function populateChannelFilter() {
    try {
        console.log('üîÑ Populating channel filter...');
        
        // Fetch all unique channel names from the database
        const { data, error } = await supabase
            .from('messages')
            .select('channel_name')
            .order('channel_name');
        
        if (error) {
            console.error('‚ùå Error fetching channel names:', error);
            return;
        }
        
        // Get unique channel names (client-side deduplication)
        const uniqueChannels = [...new Set(data.map(row => row.channel_name))].sort();
        
        console.log(`‚úÖ Found ${uniqueChannels.length} unique channels`);
        
        // Get the select element
        const channelSelect = document.getElementById('channel-filter');
        
        // Clear existing options except "All Channels"
        while (channelSelect.children.length > 1) {
            channelSelect.removeChild(channelSelect.lastChild);
        }
        
        // Add option for each unique channel
        uniqueChannels.forEach(channelName => {
            const option = document.createElement('option');
            option.value = channelName;
            option.textContent = channelName;
            channelSelect.appendChild(option);
        });
        
        console.log('‚úÖ Channel filter populated successfully');
        
    } catch (error) {
        console.error('‚ùå Unexpected error populating channel filter:', error);
    }
}

/**
 * Populate the tag filter dropdown with all available tags
 */
async function populateTagFilter() {
    try {
        console.log('üîÑ Populating tag filter...');
        
        // Fetch all tags from the channels table
        const { data, error } = await supabase
            .from('channels')
            .select('tags');
        
        if (error) {
            console.error('‚ùå Error fetching channel tags:', error);
            return;
        }
        
        // Process tags to create a flat, unique, and sorted array
        const allTags = new Set();
        if (data) {
            data.forEach(row => {
                if (row.tags && Array.isArray(row.tags)) {
                    row.tags.forEach(tag => {
                        if (tag && tag.trim()) {
                            allTags.add(tag.trim());
                        }
                    });
                }
            });
        }
        
        const uniqueTags = Array.from(allTags).sort();
        
        console.log(`‚úÖ Found ${uniqueTags.length} unique tags`);
        
        // Get the select element
        const tagSelect = document.getElementById('tag-filter');
        
        // Clear existing options except "All Tags"
        while (tagSelect.children.length > 1) {
            tagSelect.removeChild(tagSelect.lastChild);
        }
        
        // Add option for each unique tag
        uniqueTags.forEach(tagName => {
            const option = document.createElement('option');
            option.value = tagName;
            option.textContent = tagName;
            tagSelect.appendChild(option);
        });
        
        console.log('‚úÖ Tag filter populated successfully');
        
    } catch (error) {
        console.error('‚ùå Unexpected error populating tag filter:', error);
    }
}

/**
 * Update pagination controls based on current state
 */
function updatePaginationControls() {
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const pageInfo = document.getElementById('page-info');
    
    // Update page info
    const totalPages = Math.ceil(totalMessages / pageSize);
    pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
    
    // Update button states
    prevBtn.disabled = currentPage <= 1;
    nextBtn.disabled = currentPage >= totalPages || totalPages === 0;
    
    console.log(`üìÑ Pagination: Page ${currentPage}/${totalPages}, ${totalMessages} total messages`);
}

/**
 * Get total message count for pagination
 * @param {string} channelName - Optional channel name filter
 */
async function getTotalMessageCount(channelName = null, tagName = null) {
    try {
        let query = supabase
            .from('messages')
            .select('*', { count: 'exact', head: true });
        
        // If tag filter is specified, use relational query
        if (tagName && tagName !== 'all') {
            query = supabase
                .from('messages')
                .select('*, channels!inner(tags)', { count: 'exact', head: true })
                .contains('channels.tags', [tagName]);
        }
        
        // Apply channel filter if specified
        if (channelName && channelName !== 'all') {
            query = query.eq('channel_name', channelName);
        }
        
        const { count, error } = await query;
        
        if (error) {
            console.error('‚ùå Error getting message count:', error);
            return 0;
        }
        
        return count || 0;
    } catch (error) {
        console.error('‚ùå Unexpected error getting message count:', error);
        return 0;
    }
}

/**
 * Fetch messages with pagination and optional channel filtering
 * @param {number} page - Page number (1-based)
 * @param {number} size - Number of messages per page
 * @param {string} channelName - Optional channel name filter
 */
async function fetchMessages(page = currentPage, size = pageSize, channelName = currentChannelFilter, tagName = currentTagFilter) {
    try {
        const filterText = channelName && channelName !== 'all' ? ` (filtered by channel: ${channelName})` : '';
        const tagFilterText = tagName && tagName !== 'all' ? ` (filtered by tag: ${tagName})` : '';
        console.log(`üîÑ Fetching messages - Page ${page}, Size ${size}${filterText}${tagFilterText}...`);
        
        // Show loading indicator
        showLoading();
        
        // Get total count for pagination (with same filters)
        totalMessages = await getTotalMessageCount(channelName, tagName);
        
        // Calculate offset for pagination (Supabase uses 0-based indexing)
        const offset = (page - 1) * size;
        const rangeEnd = offset + size - 1;
        
        // Build query with optional filters
        let query = supabase
            .from('messages')
            .select('*')
            .order('sent_at', { ascending: false });
        
        // If tag filter is specified, use relational query
        if (tagName && tagName !== 'all') {
            query = supabase
                .from('messages')
                .select('*, channels!inner(tags)')
                .contains('channels.tags', [tagName])
                .order('sent_at', { ascending: false });
        }
        
        // Apply channel filter if specified
        if (channelName && channelName !== 'all') {
            query = query.eq('channel_name', channelName);
        }
        
        // Apply pagination
        query = query.range(offset, rangeEnd);
        
        const { data, error } = await query;
        
        if (error) {
            console.error('‚ùå Error fetching messages:', error);
            
            // Show error message to user
            const messageFeed = document.getElementById('message-feed');
            messageFeed.innerHTML = '<p class="error">Failed to load messages. Please try again later.</p>';
            return;
        }
        
        console.log('‚úÖ Successfully fetched messages:', data);
        console.log(`üìä Retrieved ${data.length} messages (Page ${page}/${Math.ceil(totalMessages / size)})`);
        
        // Log each message for debugging
        data.forEach((message, index) => {
            console.log(`Message ${index + 1}:`, {
                id: message.message_id,
                channel: message.channel_name,
                text: message.message_text.substring(0, 100) + '...',
                sent_at: message.sent_at
            });
        });
        
        // Update current state
        currentPage = page;
        pageSize = size;
        currentChannelFilter = channelName;
        currentTagFilter = tagName;
        
        // Render messages to the page
        renderMessages(data);
        
        // Update pagination controls
        updatePaginationControls();
        
    } catch (error) {
        console.error('‚ùå Unexpected error:', error);
        
        // Show error message to user
        const messageFeed = document.getElementById('message-feed');
        messageFeed.innerHTML = '<p class="error">An unexpected error occurred. Please check the console for details.</p>';
    }
}

/**
 * Go to previous page
 */
function goToPreviousPage() {
    if (currentPage > 1) {
        fetchMessages(currentPage - 1, pageSize, currentChannelFilter, currentTagFilter);
    }
}

/**
 * Go to next page
 */
function goToNextPage() {
    const totalPages = Math.ceil(totalMessages / pageSize);
    if (currentPage < totalPages) {
        fetchMessages(currentPage + 1, pageSize, currentChannelFilter, currentTagFilter);
    }
}

/**
 * Change page size
 */
function changePageSize(newSize) {
    const newSizeNum = parseInt(newSize);
    if (newSizeNum && newSizeNum > 0) {
        // Reset to page 1 when changing page size
        fetchMessages(1, newSizeNum, currentChannelFilter, currentTagFilter);
    }
}

/**
 * Handle channel filter change
 */
function handleChannelFilterChange() {
    const channelSelect = document.getElementById('channel-filter');
    const selectedChannel = channelSelect.value;
    
    console.log(`üîÑ Channel filter changed to: ${selectedChannel}`);
    
    // Reset to page 1 when filter changes
    currentPage = 1;
    
    // Fetch messages with new filter
    fetchMessages(1, pageSize, selectedChannel, currentTagFilter);
}

/**
 * Handle tag filter dropdown change
 */
function handleTagFilterChange() {
    const tagSelect = document.getElementById('tag-filter');
    const selectedTag = tagSelect.value;
    
    console.log(`üîÑ Tag filter changed to: ${selectedTag}`);
    
    // Reset to page 1 when filter changes
    currentPage = 1;
    
    // Fetch messages with new filter
    fetchMessages(1, pageSize, currentChannelFilter, selectedTag);
}

/**
 * Setup pagination and filter event listeners
 */
function setupEventListeners() {
    // Previous button
    const prevBtn = document.getElementById('prev-btn');
    prevBtn.addEventListener('click', goToPreviousPage);
    
    // Next button
    const nextBtn = document.getElementById('next-btn');
    nextBtn.addEventListener('click', goToNextPage);
    
    // Page size selector
    const pageSizeSelect = document.getElementById('page-size-select');
    pageSizeSelect.addEventListener('change', (event) => {
        changePageSize(event.target.value);
    });
    
    // Channel filter
    const channelFilter = document.getElementById('channel-filter');
    channelFilter.addEventListener('change', handleChannelFilterChange);
    
    // Tag filter
    const tagFilter = document.getElementById('tag-filter');
    tagFilter.addEventListener('change', handleTagFilterChange);
    
    console.log('‚úÖ Event listeners setup complete');
}

/**
 * Test Supabase connection
 * This function checks if we can connect to Supabase successfully
 */
async function testConnection() {
    try {
        console.log('üîß Testing Supabase connection...');
        
        const { data, error } = await supabase
            .from('messages')
            .select('count', { count: 'exact' })
            .limit(1);
        
        if (error) {
            console.error('‚ùå Connection test failed:', error);
            return false;
        }
        
        console.log('‚úÖ Supabase connection successful!');
        console.log(`üìä Total messages in database: ${data.length > 0 ? 'Connected' : 'Empty or no access'}`);
        return true;
        
    } catch (error) {
        console.error('‚ùå Connection test error:', error);
        return false;
    }
}

/**
 * Initialize the application when the page loads
 */
async function initializeApp() {
    console.log('üöÄ Initializing Rezziter frontend...');
    
    // Setup event listeners
    setupEventListeners();
    
    // Test connection first
    const connectionOk = await testConnection();
    
    if (connectionOk) {
        // Populate both filters concurrently for better performance
        await Promise.all([populateChannelFilter(), populateTagFilter()]);
        
        // Fetch and display messages with pagination
        await fetchMessages();
    } else {
        console.error('‚ùå Cannot proceed - Supabase connection failed');
        console.log('üí° Make sure to update SUPABASE_URL and SUPABASE_ANON_KEY in main.js');
    }
}

// Run initialization when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', initializeApp);

// Also run if the script loads after DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}
</file>

<file path="auth.js">
// Simple password-based authentication for Rezziter
// For GitHub Pages: Password is loaded from config.local.js (not committed)
// For other hosting: Uses environment variable

// Try to get password from config first (GitHub Pages), then environment (other hosting)
function getAuthPassword() {
    // GitHub Pages: Check for config file
    if (window.REZZITER_CONFIG && window.REZZITER_CONFIG.authPassword) {
        return window.REZZITER_CONFIG.authPassword;
    }
    
    // Other hosting: Check if environment variables are available
    if (window.ENV && window.ENV.VITE_AUTH_PASSWORD) {
        return window.ENV.VITE_AUTH_PASSWORD;
    }
    
    // Fallback warning
    console.warn('No password configured! Create config.local.js with your password');
    return 'default_password_change_me';
}

const CORRECT_PASSWORD = getAuthPassword();
const SESSION_KEY = 'rezziter_authenticated';
const SESSION_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

/**
 * Check if user is currently authenticated
 */
function isAuthenticated() {
    const authData = localStorage.getItem(SESSION_KEY);
    if (!authData) return false;
    
    try {
        const { timestamp } = JSON.parse(authData);
        const now = Date.now();
        
        // Check if session is still valid (24 hours)
        if (now - timestamp > SESSION_DURATION) {
            localStorage.removeItem(SESSION_KEY);
            return false;
        }
        
        return true;
    } catch (e) {
        localStorage.removeItem(SESSION_KEY);
        return false;
    }
}

/**
 * Authenticate user with password
 */
function authenticate(password) {
    if (password === CORRECT_PASSWORD) {
        const authData = {
            timestamp: Date.now(),
            authenticated: true
        };
        localStorage.setItem(SESSION_KEY, JSON.stringify(authData));
        return true;
    }
    return false;
}

/**
 * Logout user
 */
function logout() {
    localStorage.removeItem(SESSION_KEY);
    window.location.href = 'login.html';
}

/**
 * Redirect to login if not authenticated
 */
function requireAuth() {
    if (!isAuthenticated()) {
        window.location.href = 'login.html';
        return false;
    }
    return true;
}

/**
 * Handle login form submission
 */
function setupLoginForm() {
    const loginForm = document.getElementById('login-form');
    const passwordInput = document.getElementById('password');
    const errorMessage = document.getElementById('error-message');
    
    if (loginForm) {
        loginForm.addEventListener('submit', (e) => {
            e.preventDefault();
            
            const password = passwordInput.value.trim();
            
            if (authenticate(password)) {
                // Redirect to main app
                window.location.href = 'index.html';
            } else {
                // Show error message
                errorMessage.textContent = 'Incorrect password. Please try again.';
                errorMessage.style.display = 'block';
                passwordInput.value = '';
                passwordInput.focus();
                
                // Hide error after 3 seconds
                setTimeout(() => {
                    errorMessage.style.display = 'none';
                }, 3000);
            }
        });
        
        // Focus password input on load
        passwordInput.focus();
    }
}

/**
 * Check if already authenticated and redirect to main app
 */
function checkAuthOnLogin() {
    if (isAuthenticated()) {
        window.location.href = 'index.html';
    }
}

// Initialize login functionality
document.addEventListener('DOMContentLoaded', () => {
    // If we're on the login page
    if (window.location.pathname.includes('login.html')) {
        checkAuthOnLogin();
        setupLoginForm();
    } else {
        // For other pages, require authentication
        requireAuth();
    }
});
</file>

<file path="channels.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rezziter - Channel Management</title>
    
    <!-- Supabase JS Client via CDN -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- Main heading container -->
    <div class="filter-container">
        <h1>Channel Management</h1>
    </div>
    
    <!-- Channel list container -->
    <div id="channel-list"></div>
    
    <!-- Back to main page link -->
    <div class="pagination-container">
        <a href="index.html" class="pagination-btn" style="text-decoration: none;">Back to Message Feed</a>
    </div>
    
    <!-- Custom JavaScript -->
    <script src="channels.js"></script>
</body>
</html>
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rezziter</title>
    
    <!-- Supabase JS Client via CDN -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- Channel filter container -->
    <div class="filter-container">
        <label for="channel-filter" class="filter-label">Filter by channel:</label>
        <select id="channel-filter" class="channel-filter-select">
            <option value="all">All Channels</option>
        </select>
        
        <label for="tag-filter" class="filter-label">Filter by tag:</label>
        <select id="tag-filter" class="channel-filter-select">
            <option value="all">All Tags</option>
        </select>
    </div>
    
    <!-- Main message feed container -->
    <div id="message-feed"></div>
    
    <!-- Pagination controls -->
    <div id="pagination-container" class="pagination-container">
        <div class="pagination-controls">
            <button id="prev-btn" class="pagination-btn" disabled>Previous</button>
            <span id="page-info" class="page-info">Page 1</span>
            <button id="next-btn" class="pagination-btn">Next</button>
        </div>
        
        <div class="page-size-control">
            <label for="page-size-select">Messages per page:</label>
            <select id="page-size-select" class="page-size-select">
                <option value="10">10</option>
                <option value="20" selected>20</option>
                <option value="50">50</option>
                <option value="100">100</option>
            </select>
        </div>
    </div>
    
    <!-- Navigation to channel management -->
    <div style="text-align: center; margin-bottom: 2rem;">
        <a href="channels.html" class="pagination-btn" style="text-decoration: none;">Manage Channels</a>
    </div>
    
    <!-- Custom JavaScript -->
    <script src="main.js"></script>
</body>
</html>
</file>

<file path="channels.js">
// Rezziter - Channel Management JavaScript

// Initialize Supabase client
// NOTE: These are public keys and are safe to expose in frontend code
// Replace these placeholder values with your actual Supabase project credentials
const SUPABASE_URL = 'https://ifdmncyrdvfxkeyzwcgr.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlmZG1uY3lyZHZmeGtleXp3Y2dyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQyMDM5NjMsImV4cCI6MjA2OTc3OTk2M30.B6h3TVKkRYW637P-NfZio_0vCQWEtN70-Z5UA_H26uE';

const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/**
 * Load and display all unique channels from the messages table
 */
async function loadChannels() {
    const channelListDiv = document.getElementById('channel-list');
    
    // Show loading message
    channelListDiv.innerHTML = '<div class="message-item"><p>Loading...</p></div>';
    
    try {
        // Fetch all channel_id and channel_name pairs from messages table
        const { data, error } = await supabase
            .from('messages')
            .select('channel_id, channel_name');
        
        if (error) {
            console.error('Error fetching channels:', error);
            channelListDiv.innerHTML = '<div class="message-item"><p>Error loading channels.</p></div>';
            return;
        }
        
        // Fetch existing tags from channels table
        const { data: channelTags, error: tagsError } = await supabase
            .from('channels')
            .select('channel_id, tags');
        
        if (tagsError) {
            console.error('Error fetching channel tags:', tagsError);
            // Continue without tags rather than failing completely
        }
        
        // Create a Map to store existing tags by channel_id
        const tagsMap = new Map();
        if (channelTags) {
            channelTags.forEach(row => {
                tagsMap.set(row.channel_id, row.tags || []);
            });
        }
        
        // Create a Map to get unique channels by channel_id
        const channelMap = new Map();
        data.forEach(row => {
            if (!channelMap.has(row.channel_id)) {
                channelMap.set(row.channel_id, {
                    id: row.channel_id,
                    name: row.channel_name
                });
            }
        });
        
        // Convert Map to array and sort by channel name
        const uniqueChannels = Array.from(channelMap.values()).sort((a, b) => a.name.localeCompare(b.name));
        
        // Clear loading message
        channelListDiv.innerHTML = '';
        
        // Render each channel
        uniqueChannels.forEach(channel => {
            const channelDiv = document.createElement('div');
            channelDiv.className = 'message-item';
            
            // Get existing tags for this channel
            const existingTags = tagsMap.get(channel.id) || [];
            const tagsValue = existingTags.join(', ');
            
            channelDiv.innerHTML = `
                <h2>${channel.name}</h2>
                <div style="margin: 10px 0;">
                    <label for="tags-${channel.id}">Tags:</label>
                    <input type="text" id="tags-${channel.id}" value="${tagsValue}" placeholder="Enter tags separated by commas (e.g., news, tech)" style="width: 300px; margin-left: 10px; padding: 5px;">
                </div>
                <div style="margin: 10px 0;">
                    <button class="pagination-btn" onclick="handleTagUpdate(${channel.id}, '${channel.name.replace(/'/g, "\\'")}')">Save Tags</button>
                    <button class="pagination-btn" style="background-color: #ef4444; margin-left: 10px;" onclick="handleCleanup(${channel.id}, '${channel.name.replace(/'/g, "\\'")}')">Clean Up</button>
                </div>
            `;
            
            channelListDiv.appendChild(channelDiv);
        });
        
    } catch (error) {
        console.error('Unexpected error:', error);
        channelListDiv.innerHTML = '<div class="message-item"><p>Unexpected error occurred.</p></div>';
    }
}

/**
 * Handle updating tags for a specific channel
 * @param {number} channelId - The channel ID to update tags for
 * @param {string} channelName - The channel name for the database record
 */
async function handleTagUpdate(channelId, channelName) {
    try {
        // Find the tag input element
        const tagsInput = document.getElementById(`tags-${channelId}`);
        if (!tagsInput) {
            alert('Error: Could not find tag input field.');
            return;
        }
        
        // Read and process the tag string
        const tagsString = tagsInput.value;
        const tagsArray = tagsString
            .split(',')
            .map(tag => tag.trim())
            .filter(tag => tag.length > 0);
        
        // Upsert the record into the channels table
        const { error } = await supabase
            .from('channels')
            .upsert({
                channel_id: channelId,
                channel_name: channelName,
                tags: tagsArray
            }, { onConflict: 'channel_id' });
        
        if (error) {
            console.error('Error saving tags:', error);
            alert(`Failed to save tags for "${channelName}". Error: ${error.message}`);
        } else {
            alert(`Successfully saved tags for "${channelName}".`);
        }
    } catch (error) {
        console.error('Unexpected error saving tags:', error);
        alert(`Unexpected error occurred while saving tags for "${channelName}". Please try again.`);
    }
}

/**
 * Save tags for a specific channel (legacy function - calls handleTagUpdate)
 * @param {number} channelId - The channel ID to save tags for
 */
function saveTags(channelId) {
    // This function is kept for backwards compatibility
    // Find the channel name from the current display
    const channelElement = document.querySelector(`#tags-${channelId}`);
    const channelName = channelElement ? 
        channelElement.closest('.message-item').querySelector('h2').textContent : 
        `Channel ${channelId}`;
    
    handleTagUpdate(channelId, channelName);
}

/**
 * Handle cleanup of messages for a specific channel
 * @param {number} channelId - The channel ID to clean up
 * @param {string} channelName - The channel name for the confirmation dialog
 */
async function handleCleanup(channelId, channelName) {
    // Show confirmation dialog with channel name and warning
    const confirmed = confirm(
        `Are you sure you want to delete all messages from "${channelName}"?\n\n` +
        `This action is PERMANENT and CANNOT be undone.\n\n` +
        `All messages from this channel will be permanently removed from the database.`
    );
    
    if (!confirmed) {
        return; // User cancelled the operation
    }
    
    try {
        // Delete all messages for this channel
        const { error } = await supabase
            .from('messages')
            .delete()
            .eq('channel_id', channelId);
        
        if (error) {
            console.error('Error deleting messages:', error);
            alert(`Failed to delete messages from "${channelName}". Error: ${error.message}`);
        } else {
            alert(`Successfully deleted all messages from "${channelName}".`);
            // Optionally reload the channels to refresh the display
            loadChannels();
        }
    } catch (error) {
        console.error('Unexpected error during cleanup:', error);
        alert(`Unexpected error occurred while deleting messages from "${channelName}". Please try again.`);
    }
}

/**
 * Clean up channel (legacy function - calls handleCleanup)
 * @param {number} channelId - The channel ID to clean up
 */
function cleanUpChannel(channelId) {
    // This function is kept for backwards compatibility
    // Find the channel name from the current display
    const channelElement = document.querySelector(`#tags-${channelId}`);
    const channelName = channelElement ? 
        channelElement.closest('.message-item').querySelector('h2').textContent : 
        `Channel ${channelId}`;
    
    handleCleanup(channelId, channelName);
}

// Initialize the page when DOM is loaded
document.addEventListener('DOMContentLoaded', loadChannels);
</file>

<file path="style.css">
/* Rezziter - Modern Dark Theme CSS */

/* Reset and base styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
    background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
    color: #e4e4e7;
    line-height: 1.6;
    min-height: 100vh;
}

/* Header styling */
h1 {
    color: #f8fafc;
    font-size: 2.5rem;
    font-weight: 700;
    text-align: center;
    margin-bottom: 1rem;
    background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

/* Main container */
#message-feed, #channel-list {
    max-width: 900px;
    margin: 0 auto;
    padding: 2rem 1rem;
}

/* Filter container */
.filter-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 2rem 1rem 1rem 1rem;
    display: flex;
    align-items: center;
    gap: 1rem;
    background: rgba(24, 24, 27, 0.8);
    backdrop-filter: blur(10px);
    border-radius: 1rem;
    border: 1px solid rgba(39, 39, 42, 0.5);
    margin-bottom: 2rem;
}

.filter-label {
    color: #f1f5f9;
    font-size: 0.9rem;
    font-weight: 600;
    white-space: nowrap;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.channel-filter-select {
    background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
    color: #f9fafb;
    border: 1px solid #6b7280;
    padding: 0.75rem 1rem;
    border-radius: 0.5rem;
    font-size: 0.9rem;
    cursor: pointer;
    min-width: 12rem;
    transition: all 0.3s ease;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

.channel-filter-select:focus {
    outline: none;
    border-color: #60a5fa;
    box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.3), 0 8px 25px -5px rgba(0, 0, 0, 0.1);
    transform: translateY(-1px);
}

.channel-filter-select:hover {
    border-color: #9ca3af;
    transform: translateY(-1px);
    box-shadow: 0 8px 25px -5px rgba(0, 0, 0, 0.2);
}

/* Utility classes */
.loading {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 2rem;
    color: #a1a1aa;
    font-style: italic;
}

.empty-state {
    text-align: center;
    padding: 2rem;
    color: #a1a1aa;
    font-size: 1.1rem;
    font-style: italic;
}

.error {
    background-color: #ef4444;
    color: white;
    padding: 1rem;
    border-radius: 0.5rem;
    margin: 1rem 0;
    text-align: center;
}

.success {
    background-color: #22c55e;
    color: white;
    padding: 1rem;
    border-radius: 0.5rem;
    margin: 1rem 0;
}

/* Message styling */
.message-item {
    background: linear-gradient(135deg, rgba(24, 24, 27, 0.9) 0%, rgba(39, 39, 42, 0.7) 100%);
    border: 1px solid rgba(63, 63, 70, 0.5);
    border-radius: 1rem;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    transition: all 0.3s ease-in-out;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

.message-item:hover {
    background: linear-gradient(135deg, rgba(31, 31, 35, 0.9) 0%, rgba(63, 63, 70, 0.7) 100%);
    border-color: rgba(96, 165, 250, 0.4);
    transform: translateY(-2px);
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
}

.message-header {
    color: #f4f4f5;
    margin-bottom: 0.75rem;
    font-size: 0.9rem;
    font-weight: 500;
}

.message-header strong {
    background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-weight: 600;
}

.message-text {
    color: #e4e4e7;
    line-height: 1.6;
    margin-bottom: 0.5rem;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.message-media {
    margin-top: 0.75rem;
}

.message-image {
    max-width: 100%;
    height: auto;
    border-radius: 0.5rem;
    border: 1px solid #27272a;
}

.media-link {
    color: #60a5fa !important;
    text-decoration: underline;
    display: inline-block;
    margin-top: 0.5rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    background-color: #1e293b;
    transition: background-color 0.2s ease;
}

.media-link:hover {
    background-color: #334155;
    text-decoration: none;
}

.media-error {
    color: #f87171;
    font-style: italic;
    font-size: 0.9rem;
    margin-top: 0.5rem;
}

/* Pagination styling */
.pagination-container {
    max-width: 800px;
    margin: 2rem auto;
    padding: 0 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
}

.pagination-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.pagination-btn {
    background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
    color: #f9fafb;
    border: 1px solid #6b7280;
    padding: 0.75rem 1.5rem;
    border-radius: 0.5rem;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 500;
    transition: all 0.3s ease;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    text-decoration: none;
    display: inline-block;
}

.pagination-btn:hover:not(:disabled) {
    background: linear-gradient(135deg, #4b5563 0%, #6b7280 100%);
    border-color: #9ca3af;
    transform: translateY(-1px);
    box-shadow: 0 8px 25px -5px rgba(0, 0, 0, 0.2);
}

.pagination-btn:disabled {
    background: linear-gradient(135deg, #1f2937 0%, #374151 100%);
    color: #6b7280;
    cursor: not-allowed;
    opacity: 0.6;
    transform: none;
}

/* Special styling for the red cleanup button */
.pagination-btn[style*="background-color: #ef4444"] {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
    border-color: #dc2626;
}

.pagination-btn[style*="background-color: #ef4444"]:hover {
    background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%) !important;
    border-color: #b91c1c;
}

.page-info {
    color: #e5e7eb;
    font-weight: 500;
    font-size: 0.9rem;
    min-width: 4rem;
    text-align: center;
}

.page-size-control {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.page-size-control label {
    color: #e5e7eb;
    font-size: 0.9rem;
    white-space: nowrap;
}

.page-size-select {
    background-color: #374151;
    color: #f9fafb;
    border: 1px solid #4b5563;
    padding: 0.5rem;
    border-radius: 0.375rem;
    font-size: 0.9rem;
    cursor: pointer;
    min-width: 4rem;
}

.page-size-select:focus {
    outline: none;
    border-color: #60a5fa;
    box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.2);
}

/* Modern input styling for tag inputs */
input[type="text"] {
    background: linear-gradient(135deg, rgba(55, 65, 81, 0.8) 0%, rgba(75, 85, 99, 0.6) 100%);
    border: 1px solid #6b7280;
    color: #f9fafb;
    padding: 0.75rem 1rem;
    border-radius: 0.5rem;
    font-size: 0.9rem;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1);
}

input[type="text"]:focus {
    outline: none;
    border-color: #60a5fa;
    box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.3), 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    transform: translateY(-1px);
}

input[type="text"]:hover {
    border-color: #9ca3af;
}

/* Tag input labels */
label[for*="tags-"] {
    color: #f1f5f9;
    font-weight: 600;
    margin-right: 0.5rem;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

/* Channel management specific styling */
h2 {
    color: #f8fafc;
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 1rem;
    background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

/* Loading and empty states with better styling */
.loading {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 3rem;
    color: #a1a1aa;
    font-style: italic;
    font-size: 1.1rem;
}

.empty-state {
    text-align: center;
    padding: 3rem;
    color: #a1a1aa;
    font-size: 1.2rem;
    font-style: italic;
    background: rgba(24, 24, 27, 0.5);
    border-radius: 1rem;
    border: 1px solid rgba(39, 39, 42, 0.5);
}

/* Responsive design */
@media (max-width: 768px) {
    h1 {
        font-size: 2rem;
    }
    
    #message-feed, #channel-list {
        padding: 1rem 0.5rem;
    }
    
    .filter-container {
        padding: 1rem 0.5rem 0.5rem 0.5rem;
        flex-direction: column;
        align-items: stretch;
        gap: 0.75rem;
        margin: 1rem 0.5rem 2rem 0.5rem;
    }
    
    .filter-label {
        text-align: center;
    }
    
    .channel-filter-select {
        width: 100%;
        min-width: auto;
    }
    
    .message-item {
        padding: 1rem;
        margin-bottom: 1rem;
    }
    
    .pagination-container {
        flex-direction: column;
        align-items: stretch;
        gap: 1rem;
    }
    
    .pagination-controls {
        justify-content: center;
    }
    
    .page-size-control {
        justify-content: center;
        flex-wrap: wrap;
    }
    
    .page-size-control label {
        text-align: center;
    }
    
    input[type="text"] {
        width: 100% !important;
        margin-left: 0 !important;
        margin-top: 0.5rem;
    }
}

/* Smooth fade-in animation for content */
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.message-item, .filter-container {
    animation: fadeIn 0.3s ease-out;
}

/* Subtle pulse animation for loading states */
@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

.loading {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}
</file>

</files>
